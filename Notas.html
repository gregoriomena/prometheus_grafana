<html>
	<head>
		<style>
			img{
				border: 1px solid #555;
				margin-top: 5px;
			}
		</style>
	</head>
	<body>
		<div title="Datos curso" style='border:2px black solid; padding-left: 25px;'>
			<h1 style='margin-bottom: 0px;'>Monitoreo con Prometheus, Grafana, Spring boot y Docker</h1>
			<hr/>
			<ul style='margin-top: 5px;'>
				<li>Autor: Alejandro Agapito Bautista</li>
				<li>Fuente: <a href="https://www.udemy.com/course/devs4j-monitoring/">Udemy</a>
				</li>
				<li>Duración: 3,5 horas de vídeo</li>
			</ul>
			<hr/>
		</div>
		<ul>
			<li>
				Sección 1: Introducción a Micrometer
				<ul>
					<li>1. Introducción</li>
					<li><a href="#sec12">2. Características de un sistema de monitoreo</a></li>
					<li>3. Creación de un proyecto simple de Micrometer</li>
					<li><a href="#sec14">4. Uso del MeterRegistry</a></li>
					<li><a href="#sec15">5. Uso del CompositeMeterRegistry</a></li>
					<li><a href="#sec16">6. Uso del GlobalRegistry</a></li>
					<li><a href="#sec17">7. Tipos de Medidas</a></li>
					<li><a href="#sec18">8. Convención de nombres en los sistemas de monitoreo</a></li>
					<li><a href="#sec19">9. Uso de Counters</a></li>
					<li><a href="#sec110">10. Uso de Timers</a></li>
					<li><a href="#sec111">11. Uso de Gauge</a></li>
				</ul>
			</li>
			<li>
				Sección 2: Análisis de una aplicación REST y el ecosistema de métricas
				<ul>
					<li><a href="#sec212">12. Creación de proyecto de Spring Framework con Micrometer</a></li>
					<li><a href="#sec213">13. Habilitando endpoints de Actuator</a></li>
					<li>14. Analizando las métricas que expone Spring</li>
					<li><a href="#sec215">15. Creando una métrica personalizada en Spring</a></li>
					<li><a href="#sec216">16. PrometheusMeterRegistry y el formato de Prometheuss</a></li>
					<li><a href="#sec217">17. Uso de Timer con Spring framework</a></li>
					<li>18. Formato de Prometheus para los Timers</li>
				</ul>
			</li>
			<li>
				Sección 3: Integración de Spring con Prometheus
				<ul>
					<li>19. Instalación de Docker</li>
					<li><a href="#sec320">20. Descargando Prometheus utilizando Docker</a></li>
					<li><a href="#sec321">21. Conectando la imagen de Prometheus a nuestra aplicación</a></li>
					<li>22. Probando la integración con Prometheus</li>
					<li><a href="#sec323">23. Leyendo las métricas personalizadas de Spring desde</a></li>
					<li><a href="#sec324">24. Descargando e iniciando imagen de Grafana</a></li>
					<li><a href="#sec325">25. Integrando Prometheus con Grafana</a></li>
				</ul>
			</li>
		</ul>
		
		<span id="sec12">
			<h3>1.2 - Características de un sistema de monitoreo</h3>
			<ul>
			<li><b>Dimensionamiento:</b> Existen sistemas jerárquicos (podremos navegar a través de las métricas y existe una dependencia entre ellas) y dimensional, las métricas se aplanan y no existe una jerarquía pero tienen tags que 
			permiten clasificar la información. Por ejemplo, si tengo una métrica que es el sueldo promedio, aplicaría a todos los empleados, pero a esa métrica le puedo agregar un tag que sea el puesto.</li>
			<li><b>Rate agregation:</b> Cuando se simplifica un conjunto de datos, por ejemplo agrupándolos (promedio, suma, ...) en un periodo de tiempo.</li>
			<li><b>Publishing:</b> Algunos sistemas esperan consumir métricas desde las aplicaciones y otros esperan que se publiquen de forma regular. (Prometheus es del tipo que las consume)</li>
			</ul>
		</span>
		<span id="sec14">
			<h3>1.4. Uso del MeterRegistry</h3>
			Una Medida es la interfaz para recolectar un conjunto de datos sobre tu aplicación. En Micrometer una medida se crea y mantiene en un MeterRegistry. Cada sistema de monitoreo tiene su propia implementación del MeterRegistry (por ejemplo, Prometheus tiene la suya).
			<br />
			<br />
			La implementación de Micrometer del MeterRegistry se llama SimpleMeterRegistry, la cual mantiene el último valor de cada medida en memoria y no exporta la información a ningún lugar. Ideal en caso de que no tengas alguna preferencia con un sistema de monitoreo (SimpleMeterRegistry es como el log4j en los logs)
			<br />
			<br />
			En aplicaciones basadas en Spring SimpleMeterRegistry es inyectado por default, si se incluye la dependencia de Prometheus el registry por default es PrometheusMeterRegistry
		</span>
		<span id="sec15">
			<h3>1.5. Uso del CompositeMeterRegistry</h3>
			Micrometer provee un CompositeMeterRegistry donde puedes agregar múltiples registros, permitiendo publicar métricas a más de un sistema de monitoreo de forma simultanea.
			<br />
			<br />
			Podría ser una opción si por ejemplo se está migrando de un sistema a otro y mientras queremos publicar para ambos.
		</span>
		<span id="sec16">
			<h3>1.6. Uso del GlobalRegistry</h3>
			Micrometer provee un registro global static, para acceder a el puedes utilizar. Gracias a esto evitamos tener que crear el MeterRegistry en cada punto de la aplicación donde se quiera usar.
		</span>
		<span id="sec17">
			<h3>1.7. Tipos de Medidas</h3>
			Micrometer viene con un conjunto de medidas soportadas entre las que se encuentran:
			<ul>
				<li>Timer</li>
				<li>Counter</li>
				<li>Gauge</li>
				<li>DistributionSummary</li>
				<li>LongTaskTimer</li>
				<li>FunctionCounter</li>
				<li>TimeGauge</li>
			</ul>	
			Una medida es identificada por su nombre y dimensión. Se utiliza el término dimensión y tags de forma indistinta. Dimensiones permiten a un nombre de métrica en particular ser partida para analizar los datos a profundidad.
		</span>
		<span id="sec18">
			<h3>1.8. Convención de nombres en los sistemas de monitoreo</h3>
			Micrometer emplea una convención de nombres que utiliza minúsculas separadas con un '.' punto. Diferentes sistemas de monitoreo tienen diferentes sistemas de nombrado por lo que cada implementación de micrometer viene con un transformador a la estructura recomendada, puedes sobreescribir la convención de nombres por defaul implementando la interfaz NamingConvention
		</span>
		<span id="sec19">
			<h3>1.9. Uso de Counters</h3>
			Un Counter reporta simplemente un contador sobre la propiedad específica de una aplicación. A continuación un ejemplo: meterRegistry.counter("devs4j.students", "profile","frontend").increment();
			<br /><a href="https://micrometer.io/docs/concepts#_counters">Documentación</a>
		</span>
		<span id="sec110">
			<h3>1.10. Uso de Timers</h3>
			Para medir latencias o frecuencia de eventos puedes utilizar Timers. Igual que los counters, se pueden crear a través de registry o con un builder. <a href="https://micrometer.io/docs/concepts#_timers">Documentación</a>
		</span>
		<span id="sec111">
			<h3>1.11. Uso de Gauge</h3>
			Un Gauge muestra el valor actual de una medida, son utilizados para monitorear estadísticas de cache, colecciones, etc.
		</span>
		<span id="sec212">
			<h3>2.12. Creación de proyecto de Spring Framework con Micrometer</h3>
			Creó un proyecto base con las siguientes dependencias <br />
			<img src="./notas/curso01.png" />
		</span>
		<span id="sec213">
			<h3>2.13. Habilitando endpoints de Actuator</h3>
			Si arrancamos la aplicación base creada en el punto anterior, como se ha añadido la dependencia de Actuator, se podrá acceder a http://localhost:8080/actuator donde tendremos algunas métricas (por defecto, sólo si el servidor está activo)
			<br />Añadiendo management.endpoints.web.exposure.include= en el applitacion.properties, podemos añadir más métricas: añadiremos health (que es la que tiene por defecto) y metrics.<br />
			<br /><img src="./notas/curso02.png" />
			<br /><img src="./notas/curso03.png" />
			<br /><img src="./notas/curso04.png" />
			<br /><img src="./notas/curso05.png" />
		</span>
		<span id="sec215">
			<h3>2.15. Creando una métrica personalizada en Spring</h3>
			Tras crear nuestra propia métrica, al acceder por primera vez a http://localhost:8080/actuator/metrics no la veremos, debemos acceder al menos una vez a la nueva métrica para que luego salga en este listado.
		</span>
		<span id="sec216">
			<h3>2.16. PrometheusMeterRegistry y el formato de Prometheuss</h3>
			Si añado prometheus a la lista de métricas que se exponen (en el application.properties), y accedo a http://localhost:8080/actuator/prometheus se ve que el formato de las métricas es diferente. En /actuator/metrics/ veremos el formato de Metrics estándar, pero con prometheus ya vemos su propio formato.
		</span>
		<span id="sec217">
			<h3>2.17. Uso de Timer con Spring framework</h3>
			Podremos medir el tiempo de un trozo de código concreto con timer.record() o de todo un método con @Timed("nombre.metrica"). Esta anotación también se podría usar a nivel de clase.
		</span>
		<span id="sec320">
			<h3>3.20. Descargando Prometheus utilizando Docker</h3>
			Si buscamos Prometheus en <a href="https://hub.docker.com/r/prom/prometheus/">Docker Hub</a> encontraremos las instrucciones para instalarlo desde Docker: docker pull prom/prometheus
			<br />En la <a href="https://prometheus.io/docs/prometheus/latest/installation/">documentación de Prometheus</a> encontramos cómo poder ejecutarlo: docker run -p 9090:9090 prom/prometheus
		</span>
		<span id="sec321">
			<h3>3.21. Conectando la imagen de Prometheus a nuestra aplicación</h3>
			En el servidor de Prometheus (http://localhost:9090/) si vamos a Status->Configuration podremos obtener la configuración del servidor.
			Copiando esta configuración, podemos crear el fichero prometheus.yml y adaptarlo para apuntar a nuestro servidor.
			Teniendo este fichero, podemos arrancar Prometheus usando dicho fichero: docker run -p 9090:9090 -v C:/devel/fonts/cursoprometheusgrafana/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus -d
			Al arrancar, no encontraremos nuestra métricas, primero debemos invocar al endpoint (por ejemplo http://localhost:8080/gmenar/metrics/timermetodo) y una vez ejecutado al menos una vez, ya aparecerá en Prometheus
			<br /><img src="./notas/curso06.png" />
		</span>
		<span id="sec323">
			<h3>3.23. Leyendo las métricas personalizadas de Spring desde</h3>
			Si mostramos una métrica en Prometheus, esta irá mostrando los valores de forma acumulativa. Esto puede que no nos sea útil, por ejemplo si mi aplicación dejara de contestar no me enteraría porque me está mostrando el último valor.
			<br />Por ejmplo, si muestro el contador que había implementado en Spring, veo que la gráfica va sumando:
			<br /><img src="./notas/curso07.png" />
			<br /><br />Si usamos la función rate (número de registros por unidad de tiempo) conseguimos resolver esto<br />
			<br /><img src="./notas/curso08.png" />
			<br /><br />Podríamos usar increase en vez de rate, si lo que queremos ver es el valor real en ese periodo y no un ratio
		</span>
		<span id="sec324">
			<h3>3.24. Descargando e iniciando imagen de Grafana</h3>
			Si buscamos Grafana en <a href="https://hub.docker.com/r/grafana/grafana/">Docker Hub</a> encontraremos las instrucciones para instalarlo desde Docker: docker pull grafana/grafana
			<br />En la <a href="https://grafana.com/docs/grafana/latest/installation/docker/">documentación de Grafana</a> encontramos cómo poder ejecutarlo: docker run -d -p 3000:3000 --name=grafana -e "GF_INSTALL_PLUGINS=grafana-clock-panel,grafana-simple-json-datasource" grafana/grafana
		</span>
		<span id="sec325">
			<h3>3.25. Integrando Prometheus con Grafana</h3>
			La contraseña por defecto para acceder a Grafana (http://localhost:3000/login) es admin/admin
			<br />
			Pasos para conectar Prometheus:
			<br /><img src="./notas/curso09.png" />
			"Add data source" -> Prometheus -> Indicar la URL: http://host.docker.internal:9090/ -> Save & Test
		</span>
	</body>
</html>